import{bI as nt,bJ as Nt,bK as ht,bL as ue,bM as X,bN as ae,bO as le,bP as Ct,bQ as de,bR as he}from"./C5PuhdNm.js";(function(){try{var t=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{};t.SENTRY_RELEASE={id:"b1e593ae5130a8a866939fcd32d632e0f276c846"}}catch{}})();try{(function(){var t=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{},n=new t.Error().stack;n&&(t._sentryDebugIds=t._sentryDebugIds||{},t._sentryDebugIds[n]="0304b080-5cae-48cc-85db-4de618be0e56",t._sentryDebugIdIdentifier="sentry-dbid-0304b080-5cae-48cc-85db-4de618be0e56")})()}catch{}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const qt=BigInt(0),xt=BigInt(1);function wt(t,n=""){if(typeof t!="boolean"){const r=n&&`"${n}"`;throw new Error(r+"expected boolean, got type="+typeof t)}return t}function Q(t,n,r=""){const e=Nt(t),o=t==null?void 0:t.length,i=n!==void 0;if(!e||i&&o!==n){const s=r&&`"${r}" `,l=i?` of length ${n}`:"",a=e?`length=${o}`:`type=${typeof t}`;throw new Error(s+"expected Uint8Array"+l+", got "+a)}return t}function lt(t){const n=t.toString(16);return n.length&1?"0"+n:n}function kt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?qt:BigInt("0x"+t)}function yt(t){return kt(nt(t))}function zt(t){return ue(t),kt(nt(Uint8Array.from(t).reverse()))}function Rt(t,n){return ht(t.toString(16).padStart(n*2,"0"))}function Ht(t,n){return Rt(t,n).reverse()}function M(t,n,r){let e;if(typeof n=="string")try{e=ht(n)}catch(o){throw new Error(t+" must be hex string or Uint8Array, cause: "+o)}else if(Nt(n))e=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");return e.length,e}const mt=t=>typeof t=="bigint"&&qt<=t;function we(t,n,r){return mt(t)&&mt(n)&&mt(r)&&n<=t&&t<r}function ge(t,n,r,e){if(!we(n,r,e))throw new Error("expected valid "+t+": "+r+" <= n < "+e+", got "+n)}function Dt(t){let n;for(n=0;t>qt;t>>=xt,n+=1);return n}const st=t=>(xt<<BigInt(t))-xt;function ye(t,n,r){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");const e=h=>new Uint8Array(h),o=h=>Uint8Array.of(h);let i=e(t),s=e(t),l=0;const a=()=>{i.fill(1),s.fill(0),l=0},w=(...h)=>r(s,i,...h),m=(h=e(0))=>{s=w(o(0),h),i=w(),h.length!==0&&(s=w(o(1),h),i=w())},I=()=>{if(l++>=1e3)throw new Error("drbg: tried 1000 values");let h=0;const p=[];for(;h<n;){i=w();const x=i.slice();p.push(x),h+=i.length}return X(...p)};return(h,p)=>{a(),m(h);let x;for(;!(x=p(I()));)m();return a(),x}}function _t(t,n,r={}){if(!t||typeof t!="object")throw new Error("expected valid options object");function e(o,i,s){const l=t[o];if(s&&l===void 0)return;const a=typeof l;if(a!==i||l===null)throw new Error(`param "${o}" is invalid: expected ${i}, got ${a}`)}Object.entries(n).forEach(([o,i])=>e(o,i,!1)),Object.entries(r).forEach(([o,i])=>e(o,i,!0))}function Ut(t){const n=new WeakMap;return(r,...e)=>{const o=n.get(r);if(o!==void 0)return o;const i=t(r,...e);return n.set(r,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const j=BigInt(0),$=BigInt(1),W=BigInt(2),Xt=BigInt(3),Gt=BigInt(4),Ft=BigInt(5),me=BigInt(7),Qt=BigInt(8),be=BigInt(9),Wt=BigInt(16);function k(t,n){const r=t%n;return r>=j?r:n+r}function C(t,n,r){let e=t;for(;n-- >j;)e*=e,e%=r;return e}function Vt(t,n){if(t===j)throw new Error("invert: expected non-zero number");if(n<=j)throw new Error("invert: expected positive modulus, got "+n);let r=k(t,n),e=n,o=j,i=$;for(;r!==j;){const l=e/r,a=e%r,w=o-i*l;e=r,r=a,o=i,i=w}if(e!==$)throw new Error("invert: does not exist");return k(o,n)}function Ot(t,n,r){if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root")}function Pt(t,n){const r=(t.ORDER+$)/Gt,e=t.pow(n,r);return Ot(t,e,n),e}function pe(t,n){const r=(t.ORDER-Ft)/Qt,e=t.mul(n,W),o=t.pow(e,r),i=t.mul(n,o),s=t.mul(t.mul(i,W),o),l=t.mul(i,t.sub(s,t.ONE));return Ot(t,l,n),l}function Ee(t){const n=ct(t),r=Jt(t),e=r(n,n.neg(n.ONE)),o=r(n,e),i=r(n,n.neg(e)),s=(t+me)/Wt;return(l,a)=>{let w=l.pow(a,s),m=l.mul(w,e);const I=l.mul(w,o),f=l.mul(w,i),h=l.eql(l.sqr(m),a),p=l.eql(l.sqr(I),a);w=l.cmov(w,m,h),m=l.cmov(f,I,p);const x=l.eql(l.sqr(m),a),_=l.cmov(w,m,x);return Ot(l,_,a),_}}function Jt(t){if(t<Xt)throw new Error("sqrt is not defined for small field");let n=t-$,r=0;for(;n%W===j;)n/=W,r++;let e=W;const o=ct(t);for(;Lt(o,e)===1;)if(e++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(r===1)return Pt;let i=o.pow(e,n);const s=(n+$)/W;return function(a,w){if(a.is0(w))return w;if(Lt(a,w)!==1)throw new Error("Cannot find square root");let m=r,I=a.mul(a.ONE,i),f=a.pow(w,n),h=a.pow(w,s);for(;!a.eql(f,a.ONE);){if(a.is0(f))return a.ZERO;let p=1,x=a.sqr(f);for(;!a.eql(x,a.ONE);)if(p++,x=a.sqr(x),p===m)throw new Error("Cannot find square root");const _=$<<BigInt(m-p-1),T=a.pow(I,_);m=p,I=a.sqr(T),f=a.mul(f,I),h=a.mul(h,T)}return h}}function Be(t){return t%Gt===Xt?Pt:t%Qt===Ft?pe:t%Wt===be?Ee(t):Jt(t)}const ve=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function xe(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},r=ve.reduce((e,o)=>(e[o]="function",e),n);return _t(t,r),t}function Se(t,n,r){if(r<j)throw new Error("invalid exponent, negatives unsupported");if(r===j)return t.ONE;if(r===$)return n;let e=t.ONE,o=n;for(;r>j;)r&$&&(e=t.mul(e,o)),o=t.sqr(o),r>>=$;return e}function te(t,n,r=!1){const e=new Array(n.length).fill(r?t.ZERO:void 0),o=n.reduce((s,l,a)=>t.is0(l)?s:(e[a]=s,t.mul(s,l)),t.ONE),i=t.inv(o);return n.reduceRight((s,l,a)=>t.is0(l)?s:(e[a]=t.mul(s,e[a]),t.mul(s,l)),i),e}function Lt(t,n){const r=(t.ORDER-$)/W,e=t.pow(n,r),o=t.eql(e,t.ONE),i=t.eql(e,t.ZERO),s=t.eql(e,t.neg(t.ONE));if(!o&&!i&&!s)throw new Error("invalid Legendre symbol result");return o?1:i?0:-1}function ee(t,n){n!==void 0&&ae(n);const r=n!==void 0?n:t.toString(2).length,e=Math.ceil(r/8);return{nBitLength:r,nByteLength:e}}function ct(t,n,r=!1,e={}){if(t<=j)throw new Error("invalid field: expected ORDER > 0, got "+t);let o,i,s=!1,l;if(typeof n=="object"&&n!=null){if(e.sqrt||r)throw new Error("cannot specify opts in two arguments");const f=n;f.BITS&&(o=f.BITS),f.sqrt&&(i=f.sqrt),typeof f.isLE=="boolean"&&(r=f.isLE),typeof f.modFromBytes=="boolean"&&(s=f.modFromBytes),l=f.allowedLengths}else typeof n=="number"&&(o=n),e.sqrt&&(i=e.sqrt);const{nBitLength:a,nByteLength:w}=ee(t,o);if(w>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let m;const I=Object.freeze({ORDER:t,isLE:r,BITS:a,BYTES:w,MASK:st(a),ZERO:j,ONE:$,allowedLengths:l,create:f=>k(f,t),isValid:f=>{if(typeof f!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof f);return j<=f&&f<t},is0:f=>f===j,isValidNot0:f=>!I.is0(f)&&I.isValid(f),isOdd:f=>(f&$)===$,neg:f=>k(-f,t),eql:(f,h)=>f===h,sqr:f=>k(f*f,t),add:(f,h)=>k(f+h,t),sub:(f,h)=>k(f-h,t),mul:(f,h)=>k(f*h,t),pow:(f,h)=>Se(I,f,h),div:(f,h)=>k(f*Vt(h,t),t),sqrN:f=>f*f,addN:(f,h)=>f+h,subN:(f,h)=>f-h,mulN:(f,h)=>f*h,inv:f=>Vt(f,t),sqrt:i||(f=>(m||(m=Be(t)),m(I,f))),toBytes:f=>r?Ht(f,w):Rt(f,w),fromBytes:(f,h=!0)=>{if(l){if(!l.includes(f.length)||f.length>w)throw new Error("Field.fromBytes: expected "+l+" bytes, got "+f.length);const x=new Uint8Array(w);x.set(f,r?0:x.length-f.length),f=x}if(f.length!==w)throw new Error("Field.fromBytes: expected "+w+" bytes, got "+f.length);let p=r?zt(f):yt(f);if(s&&(p=k(p,t)),!h&&!I.isValid(p))throw new Error("invalid field element: outside of range 0..ORDER");return p},invertBatch:f=>te(I,f),cmov:(f,h,p)=>p?h:f});return Object.freeze(I)}function ne(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function re(t){const n=ne(t);return n+Math.ceil(n/2)}function Ie(t,n,r=!1){const e=t.length,o=ne(n),i=re(n);if(e<16||e<i||e>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+e);const s=r?zt(t):yt(t),l=k(s,n-$)+$;return r?Ht(l,o):Rt(l,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ot=BigInt(0),P=BigInt(1);function gt(t,n){const r=n.negate();return t?r:n}function bt(t,n){const r=te(t.Fp,n.map(e=>e.Z));return n.map((e,o)=>t.fromAffine(e.toAffine(r[o])))}function oe(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function pt(t,n){oe(t,n);const r=Math.ceil(n/t)+1,e=2**(t-1),o=2**t,i=st(t),s=BigInt(t);return{windows:r,windowSize:e,mask:i,maxNumber:o,shiftBy:s}}function Yt(t,n,r){const{windowSize:e,mask:o,maxNumber:i,shiftBy:s}=r;let l=Number(t&o),a=t>>s;l>e&&(l-=i,a+=P);const w=n*e,m=w+Math.abs(l)-1,I=l===0,f=l<0,h=n%2!==0;return{nextN:a,offset:m,isZero:I,isNeg:f,isNegF:h,offsetF:w}}function Ne(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((r,e)=>{if(!(r instanceof n))throw new Error("invalid point at index "+e)})}function qe(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((r,e)=>{if(!n.isValid(r))throw new Error("invalid scalar at index "+e)})}const Et=new WeakMap,ie=new WeakMap;function Bt(t){return ie.get(t)||1}function $t(t){if(t!==ot)throw new Error("invalid wNAF")}class Re{constructor(n,r){this.BASE=n.BASE,this.ZERO=n.ZERO,this.Fn=n.Fn,this.bits=r}_unsafeLadder(n,r,e=this.ZERO){let o=n;for(;r>ot;)r&P&&(e=e.add(o)),o=o.double(),r>>=P;return e}precomputeWindow(n,r){const{windows:e,windowSize:o}=pt(r,this.bits),i=[];let s=n,l=s;for(let a=0;a<e;a++){l=s,i.push(l);for(let w=1;w<o;w++)l=l.add(s),i.push(l);s=l.double()}return i}wNAF(n,r,e){if(!this.Fn.isValid(e))throw new Error("invalid scalar");let o=this.ZERO,i=this.BASE;const s=pt(n,this.bits);for(let l=0;l<s.windows;l++){const{nextN:a,offset:w,isZero:m,isNeg:I,isNegF:f,offsetF:h}=Yt(e,l,s);e=a,m?i=i.add(gt(f,r[h])):o=o.add(gt(I,r[w]))}return $t(e),{p:o,f:i}}wNAFUnsafe(n,r,e,o=this.ZERO){const i=pt(n,this.bits);for(let s=0;s<i.windows&&e!==ot;s++){const{nextN:l,offset:a,isZero:w,isNeg:m}=Yt(e,s,i);if(e=l,!w){const I=r[a];o=o.add(m?I.negate():I)}}return $t(e),o}getPrecomputes(n,r,e){let o=Et.get(r);return o||(o=this.precomputeWindow(r,n),n!==1&&(typeof e=="function"&&(o=e(o)),Et.set(r,o))),o}cached(n,r,e){const o=Bt(n);return this.wNAF(o,this.getPrecomputes(o,n,e),r)}unsafe(n,r,e,o){const i=Bt(n);return i===1?this._unsafeLadder(n,r,o):this.wNAFUnsafe(i,this.getPrecomputes(i,n,e),r,o)}createCache(n,r){oe(r,this.bits),ie.set(n,r),Et.delete(n)}hasCache(n){return Bt(n)!==1}}function _e(t,n,r,e){let o=n,i=t.ZERO,s=t.ZERO;for(;r>ot||e>ot;)r&P&&(i=i.add(o)),e&P&&(s=s.add(o)),o=o.double(),r>>=P,e>>=P;return{p1:i,p2:s}}function Oe(t,n,r,e){Ne(r,t),qe(e,n);const o=r.length,i=e.length;if(o!==i)throw new Error("arrays of points and scalars must have equal length");const s=t.ZERO,l=Dt(BigInt(o));let a=1;l>12?a=l-3:l>4?a=l-2:l>0&&(a=2);const w=st(a),m=new Array(Number(w)+1).fill(s),I=Math.floor((n.BITS-1)/a)*a;let f=s;for(let h=I;h>=0;h-=a){m.fill(s);for(let x=0;x<i;x++){const _=e[x],T=Number(_>>BigInt(h)&w);m[T]=m[T].add(r[x])}let p=s;for(let x=m.length-1,_=s;x>0;x--)_=_.add(m[x]),p=p.add(_);if(f=f.add(p),h!==0)for(let x=0;x<a;x++)f=f.double()}return f}function Kt(t,n,r){if(n){if(n.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return xe(n),n}else return ct(t,{isLE:r})}function Ae(t,n,r={},e){if(e===void 0&&(e=t==="edwards"),!n||typeof n!="object")throw new Error(`expected valid ${t} CURVE object`);for(const a of["p","n","h"]){const w=n[a];if(!(typeof w=="bigint"&&w>ot))throw new Error(`CURVE.${a} must be positive bigint`)}const o=Kt(n.p,r.Fp,e),i=Kt(n.n,r.Fn,e),l=["Gx","Gy","a","b"];for(const a of l)if(!o.isValid(n[a]))throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return n=Object.freeze(Object.assign({},n)),{CURVE:n,Fp:o,Fn:i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Mt=(t,n)=>(t+(t>=0?n:-n)/se)/n;function Ze(t,n,r){const[[e,o],[i,s]]=n,l=Mt(s*t,r),a=Mt(-o*t,r);let w=t-l*e-a*i,m=-l*o-a*s;const I=w<H,f=m<H;I&&(w=-w),f&&(m=-m);const h=st(Math.ceil(Dt(r)/2))+rt;if(w<H||w>=h||m<H||m>=h)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:I,k1:w,k2neg:f,k2:m}}function St(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function vt(t,n){const r={};for(let e of Object.keys(n))r[e]=t[e]===void 0?n[e]:t[e];return wt(r.lowS,"lowS"),wt(r.prehash,"prehash"),r.format!==void 0&&St(r.format),r}class Te extends Error{constructor(n=""){super(n)}}const z={Err:Te,_tlv:{encode:(t,n)=>{const{Err:r}=z;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(n.length&1)throw new r("tlv.encode: unpadded data");const e=n.length/2,o=lt(e);if(o.length/2&128)throw new r("tlv.encode: long form length too big");const i=e>127?lt(o.length/2|128):"";return lt(t)+i+o+n},decode(t,n){const{Err:r}=z;let e=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(n.length<2||n[e++]!==t)throw new r("tlv.decode: wrong tlv");const o=n[e++],i=!!(o&128);let s=0;if(!i)s=o;else{const a=o&127;if(!a)throw new r("tlv.decode(long): indefinite length not supported");if(a>4)throw new r("tlv.decode(long): byte length is too big");const w=n.subarray(e,e+a);if(w.length!==a)throw new r("tlv.decode: length bytes not complete");if(w[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const m of w)s=s<<8|m;if(e+=a,s<128)throw new r("tlv.decode(long): not minimal encoding")}const l=n.subarray(e,e+s);if(l.length!==s)throw new r("tlv.decode: wrong value length");return{v:l,l:n.subarray(e+s)}}},_int:{encode(t){const{Err:n}=z;if(t<H)throw new n("integer: negative integers are not allowed");let r=lt(t);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:n}=z;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return yt(t)}},toSig(t){const{Err:n,_int:r,_tlv:e}=z,o=M("signature",t),{v:i,l:s}=e.decode(48,o);if(s.length)throw new n("invalid signature: left bytes after parsing");const{v:l,l:a}=e.decode(2,i),{v:w,l:m}=e.decode(2,a);if(m.length)throw new n("invalid signature: left bytes after parsing");return{r:r.decode(l),s:r.decode(w)}},hexFromSig(t){const{_tlv:n,_int:r}=z,e=n.encode(2,r.encode(t.r)),o=n.encode(2,r.encode(t.s)),i=e+o;return n.encode(48,i)}},H=BigInt(0),rt=BigInt(1),se=BigInt(2),dt=BigInt(3),Ue=BigInt(4);function et(t,n){const{BYTES:r}=t;let e;if(typeof n=="bigint")e=n;else{let o=M("private key",n);try{e=t.fromBytes(o)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof n}`)}}if(!t.isValidNot0(e))throw new Error("invalid private key: out of range [1..N-1]");return e}function Ve(t,n={}){const r=Ae("weierstrass",t,n),{Fp:e,Fn:o}=r;let i=r.CURVE;const{h:s,n:l}=i;_t(n,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:a}=n;if(a&&(!e.is0(i.a)||typeof a.beta!="bigint"||!Array.isArray(a.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const w=fe(e,o);function m(){if(!e.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function I(R,d,u){const{x:c,y:g}=d.toAffine(),y=e.toBytes(c);if(wt(u,"isCompressed"),u){m();const B=!e.isOdd(g);return X(ce(B),y)}else return X(Uint8Array.of(4),y,e.toBytes(g))}function f(R){Q(R,void 0,"Point");const{publicKey:d,publicKeyUncompressed:u}=w,c=R.length,g=R[0],y=R.subarray(1);if(c===d&&(g===2||g===3)){const B=e.fromBytes(y);if(!e.isValid(B))throw new Error("bad point: is not on curve, wrong x");const E=x(B);let b;try{b=e.sqrt(E)}catch(V){const O=V instanceof Error?": "+V.message:"";throw new Error("bad point: is not on curve, sqrt error"+O)}m();const v=e.isOdd(b);return(g&1)===1!==v&&(b=e.neg(b)),{x:B,y:b}}else if(c===u&&g===4){const B=e.BYTES,E=e.fromBytes(y.subarray(0,B)),b=e.fromBytes(y.subarray(B,B*2));if(!_(E,b))throw new Error("bad point: is not on curve");return{x:E,y:b}}else throw new Error(`bad point: got length ${c}, expected compressed=${d} or uncompressed=${u}`)}const h=n.toBytes||I,p=n.fromBytes||f;function x(R){const d=e.sqr(R),u=e.mul(d,R);return e.add(e.add(u,e.mul(R,i.a)),i.b)}function _(R,d){const u=e.sqr(d),c=x(R);return e.eql(u,c)}if(!_(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const T=e.mul(e.pow(i.a,dt),Ue),it=e.mul(e.sqr(i.b),BigInt(27));if(e.is0(e.add(T,it)))throw new Error("bad curve params: a or b");function U(R,d,u=!1){if(!e.isValid(d)||u&&e.is0(d))throw new Error(`bad point coordinate ${R}`);return d}function G(R){if(!(R instanceof N))throw new Error("ProjectivePoint expected")}function D(R){if(!a||!a.basises)throw new Error("no endo");return Ze(R,a.basises,o.ORDER)}const J=Ut((R,d)=>{const{X:u,Y:c,Z:g}=R;if(e.eql(g,e.ONE))return{x:u,y:c};const y=R.is0();d==null&&(d=y?e.ONE:e.inv(g));const B=e.mul(u,d),E=e.mul(c,d),b=e.mul(g,d);if(y)return{x:e.ZERO,y:e.ZERO};if(!e.eql(b,e.ONE))throw new Error("invZ was invalid");return{x:B,y:E}}),ft=Ut(R=>{if(R.is0()){if(n.allowInfinityPoint&&!e.is0(R.Y))return;throw new Error("bad point: ZERO")}const{x:d,y:u}=R.toAffine();if(!e.isValid(d)||!e.isValid(u))throw new Error("bad point: x or y not field elements");if(!_(d,u))throw new Error("bad point: equation left != right");if(!R.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function tt(R,d,u,c,g){return u=new N(e.mul(u.X,R),u.Y,u.Z),d=gt(c,d),u=gt(g,u),d.add(u)}class N{constructor(d,u,c){this.X=U("x",d),this.Y=U("y",u,!0),this.Z=U("z",c),Object.freeze(this)}static CURVE(){return i}static fromAffine(d){const{x:u,y:c}=d||{};if(!d||!e.isValid(u)||!e.isValid(c))throw new Error("invalid affine point");if(d instanceof N)throw new Error("projective point not allowed");return e.is0(u)&&e.is0(c)?N.ZERO:new N(u,c,e.ONE)}static fromBytes(d){const u=N.fromAffine(p(Q(d,void 0,"point")));return u.assertValidity(),u}static fromHex(d){return N.fromBytes(M("pointHex",d))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(d=8,u=!0){return F.createCache(this,d),u||this.multiply(dt),this}assertValidity(){ft(this)}hasEvenY(){const{y:d}=this.toAffine();if(!e.isOdd)throw new Error("Field doesn't support isOdd");return!e.isOdd(d)}equals(d){G(d);const{X:u,Y:c,Z:g}=this,{X:y,Y:B,Z:E}=d,b=e.eql(e.mul(u,E),e.mul(y,g)),v=e.eql(e.mul(c,E),e.mul(B,g));return b&&v}negate(){return new N(this.X,e.neg(this.Y),this.Z)}double(){const{a:d,b:u}=i,c=e.mul(u,dt),{X:g,Y:y,Z:B}=this;let E=e.ZERO,b=e.ZERO,v=e.ZERO,S=e.mul(g,g),V=e.mul(y,y),O=e.mul(B,B),q=e.mul(g,y);return q=e.add(q,q),v=e.mul(g,B),v=e.add(v,v),E=e.mul(d,v),b=e.mul(c,O),b=e.add(E,b),E=e.sub(V,b),b=e.add(V,b),b=e.mul(E,b),E=e.mul(q,E),v=e.mul(c,v),O=e.mul(d,O),q=e.sub(S,O),q=e.mul(d,q),q=e.add(q,v),v=e.add(S,S),S=e.add(v,S),S=e.add(S,O),S=e.mul(S,q),b=e.add(b,S),O=e.mul(y,B),O=e.add(O,O),S=e.mul(O,q),E=e.sub(E,S),v=e.mul(O,V),v=e.add(v,v),v=e.add(v,v),new N(E,b,v)}add(d){G(d);const{X:u,Y:c,Z:g}=this,{X:y,Y:B,Z:E}=d;let b=e.ZERO,v=e.ZERO,S=e.ZERO;const V=i.a,O=e.mul(i.b,dt);let q=e.mul(u,y),A=e.mul(c,B),L=e.mul(g,E),K=e.add(u,c),Z=e.add(y,B);K=e.mul(K,Z),Z=e.add(q,A),K=e.sub(K,Z),Z=e.add(u,g);let Y=e.add(y,E);return Z=e.mul(Z,Y),Y=e.add(q,L),Z=e.sub(Z,Y),Y=e.add(c,g),b=e.add(B,E),Y=e.mul(Y,b),b=e.add(A,L),Y=e.sub(Y,b),S=e.mul(V,Z),b=e.mul(O,L),S=e.add(b,S),b=e.sub(A,S),S=e.add(A,S),v=e.mul(b,S),A=e.add(q,q),A=e.add(A,q),L=e.mul(V,L),Z=e.mul(O,Z),A=e.add(A,L),L=e.sub(q,L),L=e.mul(V,L),Z=e.add(Z,L),q=e.mul(A,Z),v=e.add(v,q),q=e.mul(Y,Z),b=e.mul(K,b),b=e.sub(b,q),q=e.mul(K,A),S=e.mul(Y,S),S=e.add(S,q),new N(b,v,S)}subtract(d){return this.add(d.negate())}is0(){return this.equals(N.ZERO)}multiply(d){const{endo:u}=n;if(!o.isValidNot0(d))throw new Error("invalid scalar: out of range");let c,g;const y=B=>F.cached(this,B,E=>bt(N,E));if(u){const{k1neg:B,k1:E,k2neg:b,k2:v}=D(d),{p:S,f:V}=y(E),{p:O,f:q}=y(v);g=V.add(q),c=tt(u.beta,S,O,B,b)}else{const{p:B,f:E}=y(d);c=B,g=E}return bt(N,[c,g])[0]}multiplyUnsafe(d){const{endo:u}=n,c=this;if(!o.isValid(d))throw new Error("invalid scalar: out of range");if(d===H||c.is0())return N.ZERO;if(d===rt)return c;if(F.hasCache(this))return this.multiply(d);if(u){const{k1neg:g,k1:y,k2neg:B,k2:E}=D(d),{p1:b,p2:v}=_e(N,c,y,E);return tt(u.beta,b,v,g,B)}else return F.unsafe(c,d)}multiplyAndAddUnsafe(d,u,c){const g=this.multiplyUnsafe(u).add(d.multiplyUnsafe(c));return g.is0()?void 0:g}toAffine(d){return J(this,d)}isTorsionFree(){const{isTorsionFree:d}=n;return s===rt?!0:d?d(N,this):F.unsafe(this,l).is0()}clearCofactor(){const{clearCofactor:d}=n;return s===rt?this:d?d(N,this):this.multiplyUnsafe(s)}isSmallOrder(){return this.multiplyUnsafe(s).is0()}toBytes(d=!0){return wt(d,"isCompressed"),this.assertValidity(),h(N,this,d)}toHex(d=!0){return nt(this.toBytes(d))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(d=!0){return this.toBytes(d)}_setWindowSize(d){this.precompute(d)}static normalizeZ(d){return bt(N,d)}static msm(d,u){return Oe(N,o,d,u)}static fromPrivateKey(d){return N.BASE.multiply(et(o,d))}}N.BASE=new N(i.Gx,i.Gy,e.ONE),N.ZERO=new N(e.ZERO,e.ONE,e.ZERO),N.Fp=e,N.Fn=o;const ut=o.BITS,F=new Re(N,n.endo?Math.ceil(ut/2):ut);return N.BASE.precompute(8),N}function ce(t){return Uint8Array.of(t?2:3)}function fe(t,n){return{secretKey:n.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*n.BYTES}}function Le(t,n={}){const{Fn:r}=t,e=n.randomBytes||Ct,o=Object.assign(fe(t.Fp,r),{seed:re(r.ORDER)});function i(h){try{return!!et(r,h)}catch{return!1}}function s(h,p){const{publicKey:x,publicKeyUncompressed:_}=o;try{const T=h.length;return p===!0&&T!==x||p===!1&&T!==_?!1:!!t.fromBytes(h)}catch{return!1}}function l(h=e(o.seed)){return Ie(Q(h,o.seed,"seed"),r.ORDER)}function a(h,p=!0){return t.BASE.multiply(et(r,h)).toBytes(p)}function w(h){const p=l(h);return{secretKey:p,publicKey:a(p)}}function m(h){if(typeof h=="bigint")return!1;if(h instanceof t)return!0;const{secretKey:p,publicKey:x,publicKeyUncompressed:_}=o;if(r.allowedLengths||p===x)return;const T=M("key",h).length;return T===x||T===_}function I(h,p,x=!0){if(m(h)===!0)throw new Error("first arg must be private key");if(m(p)===!1)throw new Error("second arg must be public key");const _=et(r,h);return t.fromHex(p).multiply(_).toBytes(x)}return Object.freeze({getPublicKey:a,getSharedSecret:I,keygen:w,Point:t,utils:{isValidSecretKey:i,isValidPublicKey:s,randomSecretKey:l,isValidPrivateKey:i,randomPrivateKey:l,normPrivateKeyToScalar:h=>et(r,h),precompute(h=8,p=t.BASE){return p.precompute(h,!1)}},lengths:o})}function Ye(t,n,r={}){le(n),_t(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const e=r.randomBytes||Ct,o=r.hmac||((u,...c)=>de(n,u,X(...c))),{Fp:i,Fn:s}=t,{ORDER:l,BITS:a}=s,{keygen:w,getPublicKey:m,getSharedSecret:I,utils:f,lengths:h}=Le(t,r),p={prehash:!1,lowS:typeof r.lowS=="boolean"?r.lowS:!1,format:void 0,extraEntropy:!1},x="compact";function _(u){const c=l>>rt;return u>c}function T(u,c){if(!s.isValidNot0(c))throw new Error(`invalid signature ${u}: out of range 1..Point.Fn.ORDER`);return c}function it(u,c){St(c);const g=h.signature,y=c==="compact"?g:c==="recovered"?g+1:void 0;return Q(u,y,`${c} signature`)}class U{constructor(c,g,y){this.r=T("r",c),this.s=T("s",g),y!=null&&(this.recovery=y),Object.freeze(this)}static fromBytes(c,g=x){it(c,g);let y;if(g==="der"){const{r:v,s:S}=z.toSig(Q(c));return new U(v,S)}g==="recovered"&&(y=c[0],g="compact",c=c.subarray(1));const B=s.BYTES,E=c.subarray(0,B),b=c.subarray(B,B*2);return new U(s.fromBytes(E),s.fromBytes(b),y)}static fromHex(c,g){return this.fromBytes(ht(c),g)}addRecoveryBit(c){return new U(this.r,this.s,c)}recoverPublicKey(c){const g=i.ORDER,{r:y,s:B,recovery:E}=this;if(E==null||![0,1,2,3].includes(E))throw new Error("recovery id invalid");if(l*se<g&&E>1)throw new Error("recovery id is ambiguous for h>1 curve");const v=E===2||E===3?y+l:y;if(!i.isValid(v))throw new Error("recovery id 2 or 3 invalid");const S=i.toBytes(v),V=t.fromBytes(X(ce((E&1)===0),S)),O=s.inv(v),q=D(M("msgHash",c)),A=s.create(-q*O),L=s.create(B*O),K=t.BASE.multiplyUnsafe(A).add(V.multiplyUnsafe(L));if(K.is0())throw new Error("point at infinify");return K.assertValidity(),K}hasHighS(){return _(this.s)}toBytes(c=x){if(St(c),c==="der")return ht(z.hexFromSig(this));const g=s.toBytes(this.r),y=s.toBytes(this.s);if(c==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return X(Uint8Array.of(this.recovery),g,y)}return X(g,y)}toHex(c){return nt(this.toBytes(c))}assertValidity(){}static fromCompact(c){return U.fromBytes(M("sig",c),"compact")}static fromDER(c){return U.fromBytes(M("sig",c),"der")}normalizeS(){return this.hasHighS()?new U(this.r,s.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return nt(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return nt(this.toBytes("compact"))}}const G=r.bits2int||function(c){if(c.length>8192)throw new Error("input is too large");const g=yt(c),y=c.length*8-a;return y>0?g>>BigInt(y):g},D=r.bits2int_modN||function(c){return s.create(G(c))},J=st(a);function ft(u){return ge("num < 2^"+a,u,H,J),s.toBytes(u)}function tt(u,c){return Q(u,void 0,"message"),c?Q(n(u),void 0,"prehashed message"):u}function N(u,c,g){if(["recovered","canonical"].some(A=>A in g))throw new Error("sign() legacy options not supported");const{lowS:y,prehash:B,extraEntropy:E}=vt(g,p);u=tt(u,B);const b=D(u),v=et(s,c),S=[ft(v),ft(b)];if(E!=null&&E!==!1){const A=E===!0?e(h.secretKey):E;S.push(M("extraEntropy",A))}const V=X(...S),O=b;function q(A){const L=G(A);if(!s.isValidNot0(L))return;const K=s.inv(L),Z=t.BASE.multiply(L).toAffine(),Y=s.create(Z.x);if(Y===H)return;const at=s.create(K*s.create(O+Y*v));if(at===H)return;let Zt=(Z.x===Y?0:2)|Number(Z.y&rt),Tt=at;return y&&_(at)&&(Tt=s.neg(at),Zt^=1),new U(Y,Tt,Zt)}return{seed:V,k2sig:q}}function ut(u,c,g={}){u=M("message",u);const{seed:y,k2sig:B}=N(u,c,g);return ye(n.outputLen,s.BYTES,o)(y,B)}function F(u){let c;const g=typeof u=="string"||Nt(u),y=!g&&u!==null&&typeof u=="object"&&typeof u.r=="bigint"&&typeof u.s=="bigint";if(!g&&!y)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(y)c=new U(u.r,u.s);else if(g){try{c=U.fromBytes(M("sig",u),"der")}catch(B){if(!(B instanceof z.Err))throw B}if(!c)try{c=U.fromBytes(M("sig",u),"compact")}catch{return!1}}return c||!1}function R(u,c,g,y={}){const{lowS:B,prehash:E,format:b}=vt(y,p);if(g=M("publicKey",g),c=tt(M("message",c),E),"strict"in y)throw new Error("options.strict was renamed to lowS");const v=b===void 0?F(u):U.fromBytes(M("sig",u),b);if(v===!1)return!1;try{const S=t.fromBytes(g);if(B&&v.hasHighS())return!1;const{r:V,s:O}=v,q=D(c),A=s.inv(O),L=s.create(q*A),K=s.create(V*A),Z=t.BASE.multiplyUnsafe(L).add(S.multiplyUnsafe(K));return Z.is0()?!1:s.create(Z.x)===V}catch{return!1}}function d(u,c,g={}){const{prehash:y}=vt(g,p);return c=tt(c,y),U.fromBytes(u,"recovered").recoverPublicKey(c).toBytes()}return Object.freeze({keygen:w,getPublicKey:m,getSharedSecret:I,utils:f,lengths:h,Point:t,sign:ut,verify:R,recoverPublicKey:d,Signature:U,hash:n})}function $e(t){const n={a:t.a,b:t.b,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},r=t.Fp;let e=t.allowedPrivateKeyLengths?Array.from(new Set(t.allowedPrivateKeyLengths.map(s=>Math.ceil(s/2)))):void 0;const o=ct(n.n,{BITS:t.nBitLength,allowedLengths:e,modFromBytes:t.wrapPrivateKey}),i={Fp:r,Fn:o,allowInfinityPoint:t.allowInfinityPoint,endo:t.endo,isTorsionFree:t.isTorsionFree,clearCofactor:t.clearCofactor,fromBytes:t.fromBytes,toBytes:t.toBytes};return{CURVE:n,curveOpts:i}}function Ke(t){const{CURVE:n,curveOpts:r}=$e(t),e={hmac:t.hmac,randomBytes:t.randomBytes,lowS:t.lowS,bits2int:t.bits2int,bits2int_modN:t.bits2int_modN};return{CURVE:n,curveOpts:r,hash:t.hash,ecdsaOpts:e}}function Me(t,n){const r=n.Point;return Object.assign({},n,{ProjectivePoint:r,CURVE:Object.assign({},t,ee(r.Fn.ORDER,r.Fn.BITS))})}function je(t){const{CURVE:n,curveOpts:r,hash:e,ecdsaOpts:o}=Ke(t),i=Ve(n,r),s=Ye(i,e,o);return Me(t,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ce(t,n){const r=e=>je({...t,hash:e});return{...r(n),create:r}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const At={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},ke={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},jt=BigInt(2);function ze(t){const n=At.p,r=BigInt(3),e=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),l=BigInt(44),a=BigInt(88),w=t*t*t%n,m=w*w*t%n,I=C(m,r,n)*m%n,f=C(I,r,n)*m%n,h=C(f,jt,n)*w%n,p=C(h,o,n)*h%n,x=C(p,i,n)*p%n,_=C(x,l,n)*x%n,T=C(_,a,n)*_%n,it=C(T,l,n)*x%n,U=C(it,r,n)*m%n,G=C(U,s,n)*p%n,D=C(G,e,n)*w%n,J=C(D,jt,n);if(!It.eql(It.sqr(J),t))throw new Error("Cannot find square root");return J}const It=ct(At.p,{sqrt:ze}),De=Ce({...At,Fp:It,lowS:!0,endo:ke},he);export{De as secp256k1};
