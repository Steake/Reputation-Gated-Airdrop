const re="6.15.0";function U(n,e,t){for(let r in e){let i=e[r];Object.defineProperty(n,r,{enumerable:!0,value:i,writable:!1})}}function b(n,e){if(n==null)return"null";if(e==null&&(e=new Set),typeof n=="object"){if(e.has(n))return"[Circular]";e.add(n)}if(Array.isArray(n))return"[ "+n.map(t=>b(t,e)).join(", ")+" ]";if(n instanceof Uint8Array){const t="0123456789abcdef";let r="0x";for(let i=0;i<n.length;i++)r+=t[n[i]>>4],r+=t[n[i]&15];return r}if(typeof n=="object"&&typeof n.toJSON=="function")return b(n.toJSON(),e);switch(typeof n){case"boolean":case"number":case"symbol":return n.toString();case"bigint":return BigInt(n).toString();case"string":return JSON.stringify(n);case"object":{const t=Object.keys(n);return t.sort(),"{ "+t.map(r=>`${b(r,e)}: ${b(n[r],e)}`).join(", ")+" }"}}return"[ COULD NOT SERIALIZE ]"}function ie(n,e,t){let r=n;{const o=[];if(t){if("message"in t||"code"in t||"name"in t)throw new Error(`value will overwrite populated values: ${b(t)}`);for(const s in t){if(s==="shortMessage")continue;const c=t[s];o.push(s+"="+b(c))}}o.push(`code=${e}`),o.push(`version=${re}`),o.length&&(n+=" ("+o.join(", ")+")")}let i;switch(e){case"INVALID_ARGUMENT":i=new TypeError(n);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":i=new RangeError(n);break;default:i=new Error(n)}return U(i,{code:e}),t&&Object.assign(i,t),i.shortMessage==null&&U(i,{shortMessage:r}),i}function oe(n,e,t,r){if(!n)throw ie(e,t,r)}function N(n,e,t,r){oe(n,e,"INVALID_ARGUMENT",{argument:t,value:r})}["NFD","NFC","NFKD","NFKC"].reduce((n,e)=>{try{if("test".normalize(e)!=="test")throw new Error("bad");if(e==="NFD"&&"é".normalize("NFD")!=="é")throw new Error("broken");n.push(e)}catch{}return n},[]);function se(n,e,t){if(n instanceof Uint8Array)return n;if(typeof n=="string"&&n.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)){const r=new Uint8Array((n.length-2)/2);let i=2;for(let o=0;o<r.length;o++)r[o]=parseInt(n.substring(i,i+2),16),i+=2;return r}N(!1,"invalid BytesLike value",e||"value",n)}function R(n,e){return se(n,e)}const F="0123456789abcdef";function G(n){const e=R(n);let t="0x";for(let r=0;r<e.length;r++){const i=e[r];t+=F[(i&240)>>4]+F[i&15]}return t}function ce(n){return"0x"+n.map(e=>G(e).substring(2)).join("")}function K(n,e){N(typeof n=="string","invalid string value","str",n);let t=[];for(let r=0;r<n.length;r++){const i=n.charCodeAt(r);if(i<128)t.push(i);else if(i<2048)t.push(i>>6|192),t.push(i&63|128);else if((i&64512)==55296){r++;const o=n.charCodeAt(r);N(r<n.length&&(o&64512)===56320,"invalid surrogate pair","str",n);const s=65536+((i&1023)<<10)+(o&1023);t.push(s>>18|240),t.push(s>>12&63|128),t.push(s>>6&63|128),t.push(s&63|128)}else t.push(i>>12|224),t.push(i>>6&63|128),t.push(i&63|128)}return new Uint8Array(t)}function v(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`Wrong positive integer: ${n}`)}function J(n,...e){if(!(n instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(n.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${n.length}`)}function H(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function ae(n,e){J(n);const t=e.outputLen;if(n.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const le=n=>n instanceof Uint8Array,ue=n=>new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4)),fe=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!fe)throw new Error("Non little-endian hardware is not supported");function he(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function X(n){if(typeof n=="string"&&(n=he(n)),!le(n))throw new Error(`expected Uint8Array, got ${typeof n}`);return n}class pe{clone(){return this._cloneInto()}}function de(n){const e=r=>n().update(X(r)).digest(),t=n();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>n(),e}const S=BigInt(2**32-1),D=BigInt(32);function ge(n,e=!1){return e?{h:Number(n&S),l:Number(n>>D&S)}:{h:Number(n>>D&S)|0,l:Number(n&S)|0}}function ye(n,e=!1){let t=new Uint32Array(n.length),r=new Uint32Array(n.length);for(let i=0;i<n.length;i++){const{h:o,l:s}=ge(n[i],e);[t[i],r[i]]=[o,s]}return[t,r]}const we=(n,e,t)=>n<<t|e>>>32-t,be=(n,e,t)=>e<<t|n>>>32-t,me=(n,e,t)=>e<<t-32|n>>>64-t,Ee=(n,e,t)=>n<<t-32|e>>>64-t,[q,V,Y]=[[],[],[]],_e=BigInt(0),E=BigInt(1),Oe=BigInt(2),Se=BigInt(7),xe=BigInt(256),ke=BigInt(113);for(let n=0,e=E,t=1,r=0;n<24;n++){[t,r]=[r,(2*t+3*r)%5],q.push(2*(5*r+t)),V.push((n+1)*(n+2)/2%64);let i=_e;for(let o=0;o<7;o++)e=(e<<E^(e>>Se)*ke)%xe,e&Oe&&(i^=E<<(E<<BigInt(o))-E);Y.push(i)}const[Ie,Ce]=ye(Y,!0),j=(n,e,t)=>t>32?me(n,e,t):we(n,e,t),W=(n,e,t)=>t>32?Ee(n,e,t):be(n,e,t);function Ae(n,e=24){const t=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let s=0;s<10;s++)t[s]=n[s]^n[s+10]^n[s+20]^n[s+30]^n[s+40];for(let s=0;s<10;s+=2){const c=(s+8)%10,a=(s+2)%10,l=t[a],u=t[a+1],f=j(l,u,1)^t[c],w=W(l,u,1)^t[c+1];for(let h=0;h<50;h+=10)n[s+h]^=f,n[s+h+1]^=w}let i=n[2],o=n[3];for(let s=0;s<24;s++){const c=V[s],a=j(i,o,c),l=W(i,o,c),u=q[s];i=n[u],o=n[u+1],n[u]=a,n[u+1]=l}for(let s=0;s<50;s+=10){for(let c=0;c<10;c++)t[c]=n[s+c];for(let c=0;c<10;c++)n[s+c]^=~t[(c+2)%10]&t[(c+4)%10]}n[0]^=Ie[r],n[1]^=Ce[r]}t.fill(0)}class $ extends pe{constructor(e,t,r,i=!1,o=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=r,this.enableXOF=i,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,v(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=ue(this.state)}keccak(){Ae(this.state32,this.rounds),this.posOut=0,this.pos=0}update(e){H(this);const{blockLen:t,state:r}=this;e=X(e);const i=e.length;for(let o=0;o<i;){const s=Math.min(t-this.pos,i-o);for(let c=0;c<s;c++)r[this.pos++]^=e[o++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:r,blockLen:i}=this;e[r]^=t,t&128&&r===i-1&&this.keccak(),e[i-1]^=128,this.keccak()}writeInto(e){H(this,!1),J(e),this.finish();const t=this.state,{blockLen:r}=this;for(let i=0,o=e.length;i<o;){this.posOut>=r&&this.keccak();const s=Math.min(r-this.posOut,o-i);e.set(t.subarray(this.posOut,this.posOut+s),i),this.posOut+=s,i+=s}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return v(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(ae(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:r,outputLen:i,rounds:o,enableXOF:s}=this;return e||(e=new $(t,r,i,s,o)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=r,e.outputLen=i,e.enableXOF=s,e.destroyed=this.destroyed,e}}const Me=(n,e,t)=>de(()=>new $(e,n,t)),Le=Me(1,136,256/8);let Q=!1;const ee=function(n){return Le(n)};let te=ee;function y(n){const e=R(n,"data");return G(te(e))}y._=ee;y.lock=function(){Q=!0};y.register=function(n){if(Q)throw new TypeError("keccak256 is locked");te=n};Object.freeze(y);class Pe{constructor(){this.EPSILON=1e-9,this.PARTITION_THRESHOLD=50,this.MAX_PARTITION_SIZE=20}validateOpinion(e){const{belief:t,disbelief:r,uncertainty:i,base_rate:o}=e;if(t<0||t>1||r<0||r>1||i<0||i>1||o<0||o>1)return!1;const s=t+r+i;return Math.abs(s-1)<this.EPSILON}partitionAttestations(e,t=this.MAX_PARTITION_SIZE){const r=[];let i=[];for(const o of e)i.length>=t?(r.push([...i]),i=[o]):i.push(o);return i.length>0&&r.push(i),r}fuseOpinions(e,t,r=1,i=1){if(!this.validateOpinion(e)||!this.validateOpinion(t))throw new Error("Invalid opinion values provided");const o=r/(r+i),s=i/(r+i),{belief:c,disbelief:a,uncertainty:l,base_rate:u}=e,{belief:f,disbelief:w,uncertainty:h,base_rate:k}=t,m=o*l+s*h-o*s*l*h;if(Math.abs(m)<this.EPSILON)return this.handleCertainOpinionsFusion(e,t,o,s);let I=(o*c*h+s*f*l)/m,C=(o*a*h+s*w*l)/m,A=o*s*l*h/m;const ne=(o*u*h+s*k*l)/m;let O=I+C+A;if(Math.abs(O-1)>this.EPSILON&&O>0){const M=1/O;I*=M,C*=M,A*=M,O=1}return{belief:this.clamp(I,0,1),disbelief:this.clamp(C,0,1),uncertainty:this.clamp(A,0,1),base_rate:this.clamp(ne,0,1)}}fuseMultipleOpinions(e){if(e.length===0)return{belief:0,disbelief:0,uncertainty:1,base_rate:.5};if(e.length===1)return e[0].opinion;let t=e[0].opinion;const r=e.reduce((i,o)=>i+o.weight,0);for(let i=1;i<e.length;i++){const o=e[i].weight/r,s=e[i-1].weight/r;t=this.fuseOpinions(t,e[i].opinion,s,o)}return t}computeReputation(e,t,r=!1){const i=t.filter(f=>f.target===e&&f.expires_at>Date.now()&&this.validateOpinion(f.opinion)),o=i.length,s=r||o>this.PARTITION_THRESHOLD;let c,a=1;if(s){const f=this.partitionAttestations(i);a=f.length;const w=[];for(const h of f){const k=this.fuseMultipleOpinions(h);w.push(k)}c=this.fuseSubjectiveOpinions(w)}else c=this.fuseMultipleOpinions(i);const l=this.opinionToReputation(c),u=this.computeConfidence(c,o);return{user_address:e,score:l,opinion:c,confidence:u,computation_metadata:{algorithm_version:"EBSL-Classical-v1.0",opinion_count:o,timestamp:Date.now(),is_incremental:!1,is_partitioned:s,partition_count:s?a:void 0}}}incrementalUpdateReputation(e,t,r=.7){if(t.length===0)return e;const i=this.fuseMultipleOpinions(t),o=this.fuseOpinions(e.opinion,i,r,1-r),s=this.opinionToReputation(o),c=this.computeConfidence(o,e.computation_metadata.opinion_count+t.length);return{...e,score:s,opinion:o,confidence:c,computation_metadata:{...e.computation_metadata,opinion_count:e.computation_metadata.opinion_count+t.length,timestamp:Date.now(),is_incremental:!0,base_reputation:e.opinion}}}opinionToReputation(e){const{belief:t,uncertainty:r,base_rate:i}=e;return t+i*r}handleCertainOpinionsFusion(e,t,r,i){return{belief:r*e.belief+i*t.belief,disbelief:r*e.disbelief+i*t.disbelief,uncertainty:Math.min(e.uncertainty,t.uncertainty),base_rate:r*e.base_rate+i*t.base_rate}}clamp(e,t,r){return Math.min(Math.max(e,t),r)}computeConfidence(e,t){const r=Math.min(t/10,1),i=1-e.uncertainty;return r*i}fuseSubjectiveOpinions(e){if(e.length===0)return{belief:0,disbelief:0,uncertainty:1,base_rate:.5};if(e.length===1)return e[0];let t=e[0];for(let r=1;r<e.length;r++)t=this.fuseOpinions(t,e[r],1,1);return t}computeSetMembershipInputs(e,t){if(e.length===0)throw new Error("No attestations provided for set membership");const r=e.map(c=>{const a=JSON.stringify({source:c.source,target:c.target,belief:c.opinion.belief,disbelief:c.opinion.disbelief,uncertainty:c.opinion.uncertainty,base_rate:c.opinion.base_rate,weight:c.weight,created_at:c.created_at,expires_at:c.expires_at});return y(K(a))}),i=ce(r.map(c=>R(c))),o=y(i);let s;if(t){const c=JSON.stringify({source:t.source,target:t.target,belief:t.opinion.belief,disbelief:t.opinion.disbelief,uncertainty:t.opinion.uncertainty,base_rate:t.opinion.base_rate,weight:t.weight,created_at:t.created_at,expires_at:t.expires_at});s=y(K(c))}return{commitment:o,memberHash:s}}}const x=new Pe;let L=null,_=null;async function Ne(){return L||_||(_=(async()=>{try{console.log("[EZKL] Loading @ezkljs/engine...");const n=await import("./chunks/Dwb35DP2.js");await n.init(),console.log("[EZKL] Engine loaded successfully");const e={prove:async(t,r,i,o)=>{try{return await n.prove(t,r,i,o)}catch(s){throw console.error("[EZKL] Prove error:",s),new Error(`EZKL prove failed: ${s}`)}},verify:async(t,r,i)=>{try{return await n.verify(t,r,i)}catch(o){throw console.error("[EZKL] Verify error:",o),new Error(`EZKL verify failed: ${o}`)}},genWitness:async(t,r)=>{try{return await n.genWitness(t,r)}catch(i){throw console.error("[EZKL] GenWitness error:",i),new Error(`EZKL genWitness failed: ${i}`)}}};return L=e,e}catch(n){throw console.error("[EZKL] Failed to load engine:",n),_=null,new Error(`Failed to load EZKL engine: ${n}`)}})(),_)}const Te="ezkl-circuits",Be=1,p="circuits";class Re{constructor(){this.db=null,this.initPromise=null}async init(){if(!this.db)return this.initPromise?this.initPromise:(this.initPromise=new Promise((e,t)=>{const r=indexedDB.open(Te,Be);r.onerror=()=>{t(new Error("Failed to open IndexedDB"))},r.onsuccess=()=>{this.db=r.result,e()},r.onupgradeneeded=i=>{const o=i.target.result;o.objectStoreNames.contains(p)||o.createObjectStore(p,{keyPath:"key"}).createIndex("timestamp","timestamp",{unique:!1})}}),this.initPromise)}async put(e,t){if(await this.init(),!this.db)throw new Error("DB not initialized");return new Promise((r,i)=>{const s=this.db.transaction([p],"readwrite").objectStore(p),c={key:e,value:t,timestamp:Date.now()},a=s.put(c);a.onsuccess=()=>r(),a.onerror=()=>i(new Error(`Failed to store key: ${e}`))})}async getByKey(e){if(await this.init(),!this.db)throw new Error("DB not initialized");return new Promise((t,r)=>{const s=this.db.transaction([p],"readonly").objectStore(p).get(e);s.onsuccess=()=>{const c=s.result;t(c?c.value:null)},s.onerror=()=>r(new Error(`Failed to get key: ${e}`))})}async has(e){return await this.getByKey(e)!==null}async delete(e){if(await this.init(),!this.db)throw new Error("DB not initialized");return new Promise((t,r)=>{const s=this.db.transaction([p],"readwrite").objectStore(p).delete(e);s.onsuccess=()=>t(),s.onerror=()=>r(new Error(`Failed to delete key: ${e}`))})}async getAllKeys(){if(await this.init(),!this.db)throw new Error("DB not initialized");return new Promise((e,t)=>{const o=this.db.transaction([p],"readonly").objectStore(p).getAllKeys();o.onsuccess=()=>e(o.result),o.onerror=()=>t(new Error("Failed to get all keys"))})}async clear(){if(await this.init(),!this.db)throw new Error("DB not initialized");return new Promise((e,t)=>{const o=this.db.transaction([p],"readwrite").objectStore(p).clear();o.onsuccess=()=>e(),o.onerror=()=>t(new Error("Failed to clear store"))})}async getStats(){await this.init();const e=await this.getAllKeys();let t=0;for(const r of e){const i=await this.getByKey(r);i&&(t+=JSON.stringify(i).length)}return{totalKeys:e.length,totalSize:t}}}const g=new Re,$e="/circuits",Ue={16:"0000000000000000000000000000000000000000000000000000000000000000",32:"0000000000000000000000000000000000000000000000000000000000000000",64:"0000000000000000000000000000000000000000000000000000000000000000"};class Fe{async getCircuit(e){const t=`circuit_${e}`,r=await g.getByKey(t);if(r){if(console.log(`[CircuitManager] Cache hit for ${e} circuit`),await this.verifyIntegrity(r,e))return r;console.warn(`[CircuitManager] Cached ${e} circuit failed integrity check, re-downloading`),await g.delete(t)}console.log(`[CircuitManager] Downloading ${e} circuit...`);const i=await this.downloadCircuit(e);if(!await this.verifyIntegrity(i,e))throw new Error(`Circuit integrity error: downloaded ${e} circuit hash mismatch with manifest`);return await g.put(t,i),console.log(`[CircuitManager] Cached ${e} circuit`),i}async downloadCircuit(e){try{const t=`${$e}/ebsl_${e}`,[r,i,o]=await Promise.all([this.fetchBinary(`${t}/_compiled.wasm`),this.fetchJSON(`${t}/settings.json`),this.fetchBinary(`${t}/vk.key`)]),s=await this.calculateHash(r,o);return console.log(`[CircuitManager] Downloaded ${e} circuit (hash: ${s.substring(0,16)}...)`),{compiledCircuit:r,settings:i,verifyingKey:o,hash:s}}catch(t){throw new Error(`Failed to download ${e} circuit: ${t.message}`)}}async fetchBinary(e){const t=await fetch(e);if(!t.ok)throw new Error(`HTTP ${t.status}: ${e}`);const r=await t.arrayBuffer();return new Uint8Array(r)}async fetchJSON(e){const t=await fetch(e);if(!t.ok)throw new Error(`HTTP ${t.status}: ${e}`);return t.json()}async calculateHash(e,t){const r=new Uint8Array(e.length+t.length);r.set(e,0),r.set(t,e.length);const i=await crypto.subtle.digest("SHA-256",r);return Array.from(new Uint8Array(i)).map(c=>c.toString(16).padStart(2,"0")).join("")}async verifyIntegrity(e,t){const r=Ue[t];return!r||r.startsWith("0000")?(console.warn(`[CircuitManager] No manifest hash for ${t}, skipping verification (dev mode)`),!0):e.hash===r}async isCached(e){return g.has(`circuit_${e}`)}async clearCircuit(e){await g.delete(`circuit_${e}`),console.log(`[CircuitManager] Cleared ${e} circuit from cache`)}async clearCache(){const t=(await g.getAllKeys()).filter(r=>r.startsWith("circuit_"));for(const r of t)await g.delete(r);console.log("[CircuitManager] Cleared all circuits from cache")}async getCacheStats(){const t=(await g.getAllKeys()).filter(o=>o.startsWith("circuit_")),r=t.map(o=>o.replace("circuit_",""));let i=0;for(const o of t){const s=await g.getByKey(o);s&&(i+=s.compiledCircuit.byteLength+s.verifyingKey.byteLength+JSON.stringify(s.settings).length)}return{cachedCircuits:r,totalSize:i}}selectCircuitSize(e){return e<=16?"16":e<=32?"32":"64"}async preloadCircuits(e=["16","32"]){console.log(`[CircuitManager] Preloading circuits: ${e.join(", ")}`);const t=e.map(r=>this.getCircuit(r));await Promise.all(t),console.log("[CircuitManager] Preload complete")}}const Ke=new Fe;let T=!1,B=null,P=null,d=!1;self.onmessage=function(n){const{type:e,data:t,jobId:r}=n.data;switch(e){case"INIT":ve().then(()=>{self.postMessage({type:"INIT_SUCCESS"})}).catch(o=>{self.postMessage({type:"INIT_ERROR",error:o.message})});break;case"GENERATE_PROOF":P=r,d=!1,He(t,r).then(o=>{d||self.postMessage({type:"PROOF_GENERATED",result:o,jobId:r})}).catch(o=>{d||self.postMessage({type:"PROOF_ERROR",error:o.message,jobId:r})});break;case"CANCEL":P===t.jobId&&(d=!0,P=null,self.postMessage({type:"CANCELLED",jobId:t.jobId}));break;case"FUSE_OPINIONS":const i=We(t);self.postMessage({type:"OPINIONS_FUSED",result:i});break;default:self.postMessage({type:"UNKNOWN_TYPE",error:"Unknown message type"})}};async function ve(){T||(console.log("[ProofWorker] Initializing EZKL engine..."),B=await Ne(),T=!0,console.log("[ProofWorker] EZKL engine initialized"))}async function He(n,e){try{if(d)return;self.postMessage({type:"PROGRESS",jobId:e,progress:{stage:"Fusing opinions",progress:0}});const t=x.fuseMultipleOpinions(n.attestations);if(d)return;self.postMessage({type:"PROGRESS",jobId:e,progress:{stage:"Loading circuit",progress:20}});const r=n.circuitSize||De(n.attestations.length);if(n.useSimulation||!T){console.log("[ProofWorker] Using simulation mode");const f=await Ze(t,n.proofType,n.threshold);return{fusedOpinion:t,proof:f,publicInputs:Z(t,n.proofType,n.threshold),hash:z(f,t),mode:"simulation"}}if(d)return;const i=await Ke.getCircuit(r);if(d)return;self.postMessage({type:"PROGRESS",jobId:e,progress:{stage:"Generating witness",progress:40}});const o=je(t,n.proofType,n.threshold),s=await B.genWitness(o,i.compiledCircuit);if(d)return;self.postMessage({type:"PROGRESS",jobId:e,progress:{stage:"Generating proof",progress:60}});const c=await B.prove(s,i.provingKey,i.compiledCircuit,i.srs);if(d)return;self.postMessage({type:"PROGRESS",jobId:e,progress:{stage:"Finalizing",progress:90}});const a=Array.from(c),l=Z(t,n.proofType,n.threshold),u=z(a,t);return{fusedOpinion:t,proof:a,publicInputs:l,hash:u,mode:"ezkl",circuitSize:r}}catch(t){throw console.error("[ProofWorker] Proof generation failed:",t),new Error(`Proof generation failed: ${t}`)}}function De(n){return n<=16?"small":n<=64?"medium":"large"}function je(n,e,t){const r=x.opinionToReputation(n),i=Math.round(r*1e6),o=Math.round(n.belief*1e6),s=Math.round(n.disbelief*1e6),c=Math.round(n.uncertainty*1e6),a=Math.round(n.base_rate*1e6);if(e==="exact")return{belief:o,disbelief:s,uncertainty:c,base_rate:a,score:i};{const l=t||6e5,u=i>=l?1:0;return{belief:o,disbelief:s,uncertainty:c,base_rate:a,score:i,threshold:l,is_above:u}}}function We(n){try{return{fusedOpinion:x.fuseMultipleOpinions(n.attestations)}}catch(e){throw new Error(`Opinion fusion failed: ${e}`)}}function Ze(n,e,t){return new Promise(r=>{setTimeout(()=>{const i=e==="exact"?8:10,o=Array.from({length:i},()=>Math.floor(Math.random()*1e6));r(o)},2e3)})}function Z(n,e,t){const r=x.opinionToReputation(n),i=Math.round(r*1e6);if(e==="exact")return[i];{const o=i>=(t||6e5)?1:0;return[t||6e5,o]}}function z(n,e){const t=n.concat([e.belief*1e6,e.disbelief*1e6,e.uncertainty*1e6,e.base_rate*1e6]);let r=0;for(let i=0;i<t.length;i++){const o=t[i];r=(r<<5)-r+o,r=r&r}return`0x${Math.abs(r).toString(16).padStart(64,"0")}`}
