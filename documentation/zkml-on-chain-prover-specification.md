# ZKML On-Chain Prover Smart Contract Specification

## Overview

This specification defines a smart contract for integrating Zero-Knowledge Machine Learning (ZKML) proofs using the Evidence-Based Subjective Logic (EBSL) algorithm with EZKL (Easy Zero-Knowledge Library) to enable on-chain verification of reputation calculations.

## Background

The ZKML On-Chain Prover enables users to prove their reputation scores were computed correctly without revealing the underlying trust network topology or individual attestations. This is achieved through:

1. **EBSL Algorithm**: A PyTorch-based trust fusion algorithm that combines multiple subjective logic opinions
2. **EZKL Integration**: Converts the PyTorch model to a zero-knowledge circuit
3. **On-chain Verification**: Smart contract that verifies ZK proofs of reputation calculations

## Core Functionality

### EBSL Fusion Process

The Evidence-Based Subjective Logic fusion algorithm operates on:

- **Opinions**: Tuples of (belief, disbelief, uncertainty, base_rate) for each attestation
- **Trust Network**: Masked representation allowing variable network sizes
- **Fusion Output**: Combined reputation score and confidence metrics

### ZK Circuit Design

The ZKML circuit implements:

```
Input: combined_tensor = concat(flatten(opinions), flatten(mask))
Process: EBSL fusion with overflow-safe operations
Output: (fused_opinion, reputation_score)
```

Key optimizations for ZK circuits:

- Overflow-safe arithmetic operations
- Stable product computation using log/exp transforms
- Sign-preserving denominator clamping
- Epsilon-bounded operations for numerical stability

## Smart Contract Specification

### Contract: `ZKMLOnChainProver`

#### State Variables

```solidity
// Verifier contract for ZKML proofs
IVerifier public immutable verifier;

// Circuit parameters
uint256 public constant MAX_OPINIONS = 16;
uint256 public constant OPINION_SIZE = 4; // [b,d,u,a]

// Proof validation parameters
uint256 public constant MIN_REPUTATION_THRESHOLD = 600000; // 0.6 in 1e6 scale
uint256 public constant MAX_REPUTATION_SCORE = 1000000;   // 1.0 in 1e6 scale

// Stored proofs and reputation scores
mapping(address => uint256) public verifiedReputations;
mapping(address => uint256) public proofTimestamps;
mapping(bytes32 => bool) public usedProofHashes;

// Administrative controls
address public owner;
bool public paused;
```

#### Events

```solidity
event ReputationVerified(
    address indexed user,
    uint256 reputationScore,
    bytes32 proofHash,
    uint256 timestamp
);

event ProofRejected(
    address indexed user,
    bytes32 proofHash,
    string reason
);

event VerifierUpdated(
    address indexed oldVerifier,
    address indexed newVerifier
);
```

#### Core Functions

##### `verifyReputationProof`

```solidity
function verifyReputationProof(
    uint256[] calldata proof,
    uint256[] calldata publicInputs
) external nonReentrant whenNotPaused returns (bool)
```

**Purpose**: Verify a ZKML proof of reputation calculation

**Parameters**:

- `proof`: ZK proof generated by EZKL
- `publicInputs`: Public inputs including reputation score

**Logic**:

1. Validate proof hasn't been used before
2. Extract reputation score from public inputs
3. Verify score is within valid range
4. Call verifier contract to validate ZK proof
5. Store verified reputation for user
6. Emit verification event

**Returns**: `true` if proof is valid and reputation is stored

##### `getVerifiedReputation`

```solidity
function getVerifiedReputation(address user)
    external view returns (uint256 reputation, uint256 timestamp)
```

**Purpose**: Retrieve verified reputation score for a user

**Returns**: Reputation score and timestamp of verification

##### `isReputationValid`

```solidity
function isReputationValid(address user, uint256 maxAge)
    external view returns (bool)
```

**Purpose**: Check if a user's reputation is valid and recent

**Parameters**:

- `user`: Address to check
- `maxAge`: Maximum age in seconds for reputation validity

**Returns**: `true` if reputation exists and is within maxAge

#### Administrative Functions

##### `updateVerifier`

```solidity
function updateVerifier(address newVerifier) external onlyOwner
```

**Purpose**: Update the verifier contract address

##### `pause/unpause`

```solidity
function pause() external onlyOwner
function unpause() external onlyOwner
```

**Purpose**: Emergency pause functionality

## ABI Specification

```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_verifier",
        "type": "address",
        "internalType": "contract IVerifier"
      }
    ]
  },
  {
    "type": "function",
    "name": "verifyReputationProof",
    "inputs": [
      {
        "name": "proof",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "publicInputs",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getVerifiedReputation",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "reputation",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "timestamp",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isReputationValid",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "maxAge",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "verifiedReputations",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proofTimestamps",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "updateVerifier",
    "inputs": [
      {
        "name": "newVerifier",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "ReputationVerified",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "reputationScore",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "proofHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "timestamp",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ProofRejected",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "proofHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "reason",
        "type": "string",
        "indexed": false,
        "internalType": "string"
      }
    ],
    "anonymous": false
  }
]
```

## Integration Architecture

### Data Flow

1. **Off-chain Computation**:
   - Collect user's attestations and opinions
   - Run EBSL fusion algorithm in PyTorch
   - Export model to ONNX format
   - Generate ZK proof using EZKL

2. **On-chain Verification**:
   - Submit proof and public inputs to smart contract
   - Contract verifies proof using EZKL verifier
   - Store verified reputation score on-chain
   - Emit verification event

3. **Frontend Integration**:
   - User initiates reputation verification
   - Frontend calls backend to generate proof
   - Submit transaction with proof to smart contract
   - Display verification status and reputation score

### Security Considerations

1. **Proof Uniqueness**: Prevent replay attacks by tracking used proof hashes
2. **Input Validation**: Ensure reputation scores are within valid bounds
3. **Circuit Integrity**: Verifier contract must match the EZKL circuit exactly
4. **Access Control**: Only verified proofs can update reputation scores

### Gas Optimization

1. **Batch Verification**: Support batch proof verification for multiple users
2. **Efficient Storage**: Use packed structs for reputation data
3. **Event Indexing**: Optimize event parameters for efficient querying

## Implementation Requirements

### Backend Components

1. **EBSL Service**: PyTorch model serving reputation calculations
2. **EZKL Prover**: Generate ZK proofs for reputation scores
3. **Proof API**: REST endpoints for proof generation and submission

### Frontend Components

1. **Reputation Dashboard**: Display verified reputation scores
2. **Proof Generation UI**: Initiate proof generation process
3. **Transaction Interface**: Submit proofs to smart contract
4. **Verification Status**: Real-time proof verification tracking

### DevOps Pipeline

1. **Circuit Compilation**: Automated EZKL circuit building
2. **Contract Deployment**: Hardhat/Foundry scripts for deployment
3. **Testing Suite**: Comprehensive test coverage for all components
4. **Monitoring**: Track proof generation and verification metrics

## Testing Strategy

### Unit Tests

1. **EBSL Algorithm**: Property-based testing with Hypothesis
2. **Smart Contract**: Foundry tests for all contract functions
3. **Frontend Components**: Vitest tests for UI components

### Integration Tests

1. **End-to-End Flow**: Complete proof generation to verification
2. **Performance Testing**: Benchmark proof generation times
3. **Security Testing**: Verify access controls and input validation

### Property-Based Testing

Using Hypothesis framework to validate:

- EBSL fusion properties (commutativity, associativity)
- Numerical stability across input ranges
- ZK circuit equivalence to classical implementation

## Deployment Considerations

### Production Environment

1. **Verifier Contract**: Deploy with proper access controls
2. **IPFS Storage**: Store circuit artifacts on IPFS
3. **Load Balancing**: Distribute proof generation across multiple workers
4. **Monitoring**: Track system health and performance metrics

### Scaling Strategies

1. **Circuit Sharding**: Split large trust networks into smaller circuits
2. **Proof Aggregation**: Combine multiple smaller proofs
3. **Caching**: Reuse compiled circuits and proving keys
4. **Async Processing**: Queue-based proof generation

This specification provides the foundation for implementing a production-ready ZKML reputation verification system with full on-chain integration.
