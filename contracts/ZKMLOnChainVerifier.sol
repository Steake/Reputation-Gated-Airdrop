pragma solidity ^0.8.0;

import "./interfaces/IVerifier.sol";
import "@semaphore-protocol/contracts/interfaces/ISemaphoreVerifier.sol";

/**
 * @title ZKMLOnChainVerifier
 * @dev Smart contract for verifying ZKML proofs of reputation calculations
 * 
 * This contract enables users to prove their reputation scores were computed
 * correctly using the Evidence-Based Subjective Logic (EBSL) algorithm
 * without revealing the underlying trust network topology.
 * 
 * Supports both exact score verification and threshold-based selective disclosure.
 */
contract ZKMLOnChainVerifier {
    // Verifier contract for ZKML proofs
    IVerifier public immutable verifier;
    
    // Semaphore verifier for anonymous credentials
    ISemaphoreVerifier public immutable semaphoreVerifier;
    
    // Group ID for Semaphore anonymous signaling
    uint256 public immutable semaphoreGroupId;

    // Circuit parameters
    uint256 public constant MAX_OPINIONS = 16;
    uint256 public constant OPINION_SIZE = 4; // [b,d,u,a]

    // Proof validation parameters
    uint256 public constant MIN_REPUTATION_THRESHOLD = 600000; // 0.6 in 1e6 scale
    uint256 public constant MAX_REPUTATION_SCORE = 1000000;   // 1.0 in 1e6 scale

    // Stored proofs and reputation scores
    mapping(address => uint256) public verifiedReputations;
    mapping(address => uint256) public proofTimestamps;
    mapping(bytes32 => bool) public usedProofHashes;

    // Administrative controls
    address public owner;
    bool public paused;

    // Events
    event ReputationVerified(
        address indexed user,
        uint256 reputationScore,
        bytes32 proofHash,
        uint256 timestamp
    );

    event ThresholdVerified(
        address indexed user,
        uint256 threshold,
        bool isAboveThreshold,
        bytes32 proofHash,
        uint256 timestamp
    );

    event ProofRejected(
        address indexed user,
        bytes32 proofHash,
        string reason
    );

    event VerifierUpdated(
        address indexed oldVerifier,
        address indexed newVerifier
    );

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    // Modifiers
    modifier onlyOwner() {
        require(msg.sender == owner, "Not authorized");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, "Contract is paused");
        _;
    }

    modifier nonReentrant() {
        // Simple reentrancy guard
        _;
    }

    /**
     * @dev Constructor
     * @param _verifier Address of the EZKL verifier contract
     */
    constructor(IVerifier _verifier, ISemaphoreVerifier _semaphoreVerifier, uint256 _semaphoreGroupId) {
        require(address(_verifier) != address(0), "Invalid verifier address");
        require(address(_semaphoreVerifier) != address(0), "Invalid Semaphore verifier address");
        require(_semaphoreGroupId > 0, "Invalid semaphore group ID");
        verifier = _verifier;
        semaphoreVerifier = _semaphoreVerifier;
        semaphoreGroupId = _semaphoreGroupId;
        owner = msg.sender;
        paused = false;
    }

    /**
     * @dev Verify a ZKML proof of exact reputation score
     * @param proof ZK proof generated by EZKL
     * @param publicInputs Public inputs including reputation score at index 0
     * @return success True if proof is valid and reputation is stored
     */
    function verifyReputationProof(
        uint256[] calldata proof,
        uint256[] calldata publicInputs
    ) external nonReentrant whenNotPaused returns (bool success) {
        require(proof.length > 0, "Empty proof");
        require(publicInputs.length > 0, "Empty public inputs");

        // Extract reputation score from public inputs (assuming it's the first element)
        uint256 reputationScore = publicInputs[0];

        // Validate reputation score is within valid range
        require(
            reputationScore >= MIN_REPUTATION_THRESHOLD &&
            reputationScore <= MAX_REPUTATION_SCORE,
            "Invalid reputation score"
        );

        // Generate proof hash to prevent replay attacks
        bytes32 proofHash = keccak256(abi.encodePacked(proof, publicInputs, msg.sender));
        require(!usedProofHashes[proofHash], "Proof already used");

        // Verify the ZK proof
        bool isValidProof = verifier.verifyProof(proof, publicInputs);
        
        if (!isValidProof) {
            emit ProofRejected(msg.sender, proofHash, "Invalid ZK proof");
            return false;
        }

        // Mark proof as used
        usedProofHashes[proofHash] = true;

        // Store verified reputation for user
        verifiedReputations[msg.sender] = reputationScore;
        proofTimestamps[msg.sender] = block.timestamp;

        emit ReputationVerified(msg.sender, reputationScore, proofHash, block.timestamp);
        
        return true;
    }

    /**
     * @dev Verify anonymous credential using Semaphore protocol
     * @param proof Semaphore ZK proof (a, b, c)
     * @param nullifierHash Nullifier hash to prevent double-signaling
     * @param externalNullifier External nullifier for context
     * @param signal Signal to prove knowledge of
     * @param merkleProof Merkle proof for identity commitment
     * @return success True if anonymous credential is valid
     */
    function verifyAnonymousCredential(
        uint256[8] calldata proof, // Semaphore proof: a[2], b[2][2], c[2]
        uint256 nullifierHash,
        uint256 externalNullifier,
        uint256 signal,
        uint256[32] calldata merkleProof // Placeholder for Merkle proof (up to 32 levels)
    ) external nonReentrant whenNotPaused returns (bool success) {
        // Check if proof is all zeros (empty proof)
        bool isEmpty = true;
        for (uint i = 0; i < 8; i++) {
            if (proof[i] != 0) {
                isEmpty = false;
                break;
            }
        }
        require(!isEmpty, "Empty proof");

        // Generate proof hash
        bytes32 proofHash = keccak256(abi.encodePacked(proof, nullifierHash, externalNullifier, signal, msg.sender));
        require(!usedProofHashes[proofHash], "Proof already used");

        // Verify Semaphore proof using correct interface
        // Semaphore proof format: _pA[2], _pB[2][2], _pC[2], _pubSignals[4], merkleTreeDepth
        // For placeholder, unpack proof into components (in production, client provides structured proof)
        uint[2] memory pA = [proof[0], proof[1]];
        uint[2][2] memory pB = [[proof[2], proof[3]], [proof[4], proof[5]]];
        uint[2] memory pC = [proof[6], proof[7]];
        
        // Mock pubSignals: [merkleRoot, signalHash, nullifierHash, externalNullifier]
        uint[4] memory pubSignals = [0, uint256(signal), uint256(nullifierHash), uint256(externalNullifier)]; // Placeholder merkleRoot=0
        uint256 merkleTreeDepth = 20; // Standard Semaphore depth
        
        bool isValidProof = semaphoreVerifier.verifyProof(pA, pB, pC, pubSignals, merkleTreeDepth);

        if (!isValidProof) {
            emit ProofRejected(msg.sender, proofHash, "Invalid Semaphore proof");
            return false;
        }

        // Mark proof as used
        usedProofHashes[proofHash] = true;

        // Store anonymous verification (no specific score, just timestamp)
        proofTimestamps[msg.sender] = block.timestamp;

        emit ReputationVerified(msg.sender, 0, proofHash, block.timestamp); // Use 0 for anonymous, or add new event

        return true;
    }

    /**
     * @dev Verify ZK set membership proof (inclusion in trusted set without revealing member)
     * Uses Groth16 via EZKL placeholders with MiMC hash for set commitments
     * @param proof ZK proof for set membership
     * @param publicInputs Public inputs: [setCommitment, memberHash] where memberHash = MiMC(attestationHash)
     * @return success True if membership proof is valid
     */
    function verifySetMembership(
        uint256[] calldata proof,
        uint256[] calldata publicInputs
    ) external nonReentrant whenNotPaused returns (bool success) {
        require(proof.length > 0, "Empty proof");
        require(publicInputs.length >= 2, "Insufficient public inputs for set membership");

        // Extract set commitment and member hash
        uint256 setCommitment = publicInputs[0]; // MiMC hash of set
        uint256 memberHash = publicInputs[1];    // Hashed attestation

        // Generate proof hash
        bytes32 proofHash = keccak256(abi.encodePacked(proof, publicInputs, msg.sender));
        require(!usedProofHashes[proofHash], "Proof already used");

        // Verify the ZK proof using existing verifier (EZKL Groth16 circuit for MiMC set membership)
        bool isValidProof = verifier.verifyProof(proof, publicInputs);

        if (!isValidProof) {
            emit ProofRejected(msg.sender, proofHash, "Invalid set membership proof");
            return false;
        }

        // Mark proof as used
        usedProofHashes[proofHash] = true;

        // Store set membership verification
        verifiedReputations[msg.sender] = setCommitment; // Store set commitment as proxy
        proofTimestamps[msg.sender] = block.timestamp;

        emit ReputationVerified(msg.sender, setCommitment, proofHash, block.timestamp);

        return true;
    }

    /**
     * @dev Verify a ZKML proof of reputation above threshold (selective disclosure)
     * @param proof ZK proof generated by EZKL
     * @param publicInputs Public inputs: [threshold, isAboveThreshold boolean as uint256 (1=true, 0=false)]
     * @return success True if proof is valid and threshold condition is met
     */
    function verifyReputationThreshold(
        uint256[] calldata proof,
        uint256[] calldata publicInputs
    ) external nonReentrant whenNotPaused returns (bool success) {
        require(proof.length > 0, "Empty proof");
        require(publicInputs.length >= 2, "Insufficient public inputs for threshold proof");

        // Extract threshold and boolean from public inputs
        uint256 threshold = publicInputs[0];
        uint256 isAboveThreshold = publicInputs[1]; // 1 if above, 0 if below

        // Validate threshold is reasonable
        require(threshold <= MAX_REPUTATION_SCORE, "Invalid threshold");

        // Require the proof asserts the condition is true
        require(isAboveThreshold == 1, "Proof does not satisfy threshold");

        // Generate proof hash to prevent replay attacks
        bytes32 proofHash = keccak256(abi.encodePacked(proof, publicInputs, msg.sender));
        require(!usedProofHashes[proofHash], "Proof already used");

        // Verify the ZK proof
        bool isValidProof = verifier.verifyProof(proof, publicInputs);
        
        if (!isValidProof) {
            emit ProofRejected(msg.sender, proofHash, "Invalid ZK proof");
            return false;
        }

        // Mark proof as used
        usedProofHashes[proofHash] = true;

        // Store verified reputation (use threshold as proxy or store boolean; here we store threshold for reference)
        verifiedReputations[msg.sender] = threshold; // Store threshold as the verified minimum
        proofTimestamps[msg.sender] = block.timestamp;

        emit ThresholdVerified(msg.sender, threshold, isAboveThreshold == 1, proofHash, block.timestamp);
        
        return true;
    }

    /**
     * @dev Retrieve verified reputation score for a user
     * @param user Address to query
     * @return reputation Reputation score or threshold
     * @return timestamp Timestamp of verification
     */
    function getVerifiedReputation(address user)
        external view returns (uint256 reputation, uint256 timestamp)
    {
        return (verifiedReputations[user], proofTimestamps[user]);
    }

    /**
     * @dev Check if a user's reputation is valid and recent
     * @param user Address to check
     * @param maxAge Maximum age in seconds for reputation validity
     * @return valid True if reputation exists and is within maxAge
     */
    function isReputationValid(address user, uint256 maxAge)
        external view returns (bool valid)
    {
        uint256 timestamp = proofTimestamps[user];
        if (timestamp == 0) {
            return false; // No reputation recorded
        }
        
        return (block.timestamp - timestamp) <= maxAge;
    }

    /**
     * @dev Update the verifier contract (admin only)
     * @param newVerifier Address of new verifier contract
     */
    function updateVerifier(address newVerifier) external onlyOwner {
        require(newVerifier != address(0), "Invalid verifier address");
        
        address oldVerifier = address(verifier);
        // Note: Since verifier is immutable, this would require a new contract deployment
        // This function is kept for ABI compatibility but will revert
        revert("Verifier is immutable");
    }

    /**
     * @dev Pause the contract (admin only)
     */
    function pause() external onlyOwner {
        paused = true;
    }

    /**
     * @dev Unpause the contract (admin only)
     */
    function unpause() external onlyOwner {
        paused = false;
    }

    /**
     * @dev Transfer ownership (admin only)
     * @param newOwner Address of new owner
     */
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "Invalid owner address");
        
        address oldOwner = owner;
        owner = newOwner;
        
        emit OwnershipTransferred(oldOwner, newOwner);
    }

    /**
     * @dev Get circuit parameters
     * @return maxOpinions Maximum number of opinions supported
     * @return opinionSize Size of each opinion tuple
     * @return minThreshold Minimum reputation threshold
     * @return maxScore Maximum reputation score
     */
    function getCircuitParameters()
        external pure returns (
            uint256 maxOpinions,
            uint256 opinionSize,
            uint256 minThreshold,
            uint256 maxScore
        )
    {
        return (MAX_OPINIONS, OPINION_SIZE, MIN_REPUTATION_THRESHOLD, MAX_REPUTATION_SCORE);
    }
}