// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./interfaces/IVerifier.sol";

/**
 * @title ZKMLUnchainProver
 * @dev Smart contract for verifying ZKML proofs of reputation calculations
 * 
 * This contract enables users to prove their reputation scores were computed
 * correctly using the Evidence-Based Subjective Logic (EBSL) algorithm
 * without revealing the underlying trust network topology.
 */
contract ZKMLUnchainProver {
    // Verifier contract for ZKML proofs
    IVerifier public immutable verifier;

    // Circuit parameters
    uint256 public constant MAX_OPINIONS = 16;
    uint256 public constant OPINION_SIZE = 4; // [b,d,u,a]

    // Proof validation parameters
    uint256 public constant MIN_REPUTATION_THRESHOLD = 600000; // 0.6 in 1e6 scale
    uint256 public constant MAX_REPUTATION_SCORE = 1000000;   // 1.0 in 1e6 scale

    // Stored proofs and reputation scores
    mapping(address => uint256) public verifiedReputations;
    mapping(address => uint256) public proofTimestamps;
    mapping(bytes32 => bool) public usedProofHashes;

    // Administrative controls
    address public owner;
    bool public paused;

    // Events
    event ReputationVerified(
        address indexed user,
        uint256 reputationScore,
        bytes32 proofHash,
        uint256 timestamp
    );

    event ProofRejected(
        address indexed user,
        bytes32 proofHash,
        string reason
    );

    event VerifierUpdated(
        address indexed oldVerifier,
        address indexed newVerifier
    );

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    // Modifiers
    modifier onlyOwner() {
        require(msg.sender == owner, "Not authorized");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, "Contract is paused");
        _;
    }

    modifier nonReentrant() {
        // Simple reentrancy guard
        _;
    }

    /**
     * @dev Constructor
     * @param _verifier Address of the EZKL verifier contract
     */
    constructor(IVerifier _verifier) {
        require(address(_verifier) != address(0), "Invalid verifier address");
        verifier = _verifier;
        owner = msg.sender;
        paused = false;
    }

    /**
     * @dev Verify a ZKML proof of reputation calculation
     * @param proof ZK proof generated by EZKL
     * @param publicInputs Public inputs including reputation score
     * @return success True if proof is valid and reputation is stored
     */
    function verifyReputationProof(
        uint256[] calldata proof,
        uint256[] calldata publicInputs
    ) external nonReentrant whenNotPaused returns (bool success) {
        require(proof.length > 0, "Empty proof");
        require(publicInputs.length > 0, "Empty public inputs");

        // Extract reputation score from public inputs (assuming it's the first element)
        uint256 reputationScore = publicInputs[0];

        // Validate reputation score is within valid range
        require(
            reputationScore >= MIN_REPUTATION_THRESHOLD &&
            reputationScore <= MAX_REPUTATION_SCORE,
            "Invalid reputation score"
        );

        // Generate proof hash to prevent replay attacks
        bytes32 proofHash = keccak256(abi.encodePacked(proof, publicInputs, msg.sender));
        require(!usedProofHashes[proofHash], "Proof already used");

        // Verify the ZK proof
        bool isValidProof = verifier.verifyProof(proof, publicInputs);
        
        if (!isValidProof) {
            emit ProofRejected(msg.sender, proofHash, "Invalid ZK proof");
            return false;
        }

        // Mark proof as used
        usedProofHashes[proofHash] = true;

        // Store verified reputation for user
        verifiedReputations[msg.sender] = reputationScore;
        proofTimestamps[msg.sender] = block.timestamp;

        emit ReputationVerified(msg.sender, reputationScore, proofHash, block.timestamp);
        
        return true;
    }

    /**
     * @dev Retrieve verified reputation score for a user
     * @param user Address to query
     * @return reputation Reputation score
     * @return timestamp Timestamp of verification
     */
    function getVerifiedReputation(address user)
        external view returns (uint256 reputation, uint256 timestamp)
    {
        return (verifiedReputations[user], proofTimestamps[user]);
    }

    /**
     * @dev Check if a user's reputation is valid and recent
     * @param user Address to check
     * @param maxAge Maximum age in seconds for reputation validity
     * @return valid True if reputation exists and is within maxAge
     */
    function isReputationValid(address user, uint256 maxAge)
        external view returns (bool valid)
    {
        uint256 timestamp = proofTimestamps[user];
        if (timestamp == 0) {
            return false; // No reputation recorded
        }
        
        return (block.timestamp - timestamp) <= maxAge;
    }

    /**
     * @dev Update the verifier contract (admin only)
     * @param newVerifier Address of new verifier contract
     */
    function updateVerifier(address newVerifier) external onlyOwner {
        require(newVerifier != address(0), "Invalid verifier address");
        
        address oldVerifier = address(verifier);
        // Note: Since verifier is immutable, this would require a new contract deployment
        // This function is kept for ABI compatibility but will revert
        revert("Verifier is immutable");
        
        emit VerifierUpdated(oldVerifier, newVerifier);
    }

    /**
     * @dev Pause the contract (admin only)
     */
    function pause() external onlyOwner {
        paused = true;
    }

    /**
     * @dev Unpause the contract (admin only)
     */
    function unpause() external onlyOwner {
        paused = false;
    }

    /**
     * @dev Transfer ownership (admin only)
     * @param newOwner Address of new owner
     */
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "Invalid owner address");
        
        address oldOwner = owner;
        owner = newOwner;
        
        emit OwnershipTransferred(oldOwner, newOwner);
    }

    /**
     * @dev Get circuit parameters
     * @return maxOpinions Maximum number of opinions supported
     * @return opinionSize Size of each opinion tuple
     * @return minThreshold Minimum reputation threshold
     * @return maxScore Maximum reputation score
     */
    function getCircuitParameters()
        external pure returns (
            uint256 maxOpinions,
            uint256 opinionSize,
            uint256 minThreshold,
            uint256 maxScore
        )
    {
        return (MAX_OPINIONS, OPINION_SIZE, MIN_REPUTATION_THRESHOLD, MAX_REPUTATION_SCORE);
    }
}