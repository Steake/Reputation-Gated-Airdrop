#!/usr/bin/env node
/**
 * Generate Mock Circuit Artifacts for ZKML Demo
 *
 * This script creates minimal valid circuit artifacts that follow the expected format
 * for the circuit-manager. These are mock files for demonstration purposes.
 *
 * In production, these would be replaced with actual EZKL-generated circuits.
 */

const fs = require("fs");
const crypto = require("crypto");
const path = require("path");

const STATIC_DIR = path.join(__dirname, "..", "static", "circuits");

// Circuit sizes (number of opinions/attestations supported)
const CIRCUIT_SIZES = [16, 32, 64];

/**
 * Generate a mock WASM file (compiled circuit)
 * In reality, this would be generated by EZKL from the ONNX model
 */
function generateMockCompiledCircuit(size) {
  // Create a minimal WASM binary header followed by mock data
  const header = Buffer.from([0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00]); // WASM magic number + version
  const mockData = Buffer.alloc(1024 * size); // Size scales with opinion count
  crypto.randomFillSync(mockData);
  return Buffer.concat([header, mockData]);
}

/**
 * Generate mock settings.json
 * These settings configure the EZKL proof generation
 */
function generateMockSettings(size) {
  return {
    run_args: {
      input_scale: 5,
      param_scale: 5,
      epsilon: 0.00001,
      logrows: 17,
      commitment: "KZG",
      input_visibility: "Private",
      output_visibility: "Public",
      param_visibility: "Private",
    },
    model_input_scales: [5],
    model_output_scales: [5],
    num_rows: 131072,
    total_assignments: size * size * 4, // N*N*4 trust matrix
    total_const_size: 1024,
    circuit_info: {
      opinion_count: size,
      circuit_type: "ebsl_fusion",
      mock: true,
    },
  };
}

/**
 * Generate mock verifying key
 * In reality, this is generated during the EZKL setup phase
 */
function generateMockVerifyingKey(size) {
  const mockVK = Buffer.alloc(256 * (1 + Math.floor(size / 16))); // VK size scales with circuit
  crypto.randomFillSync(mockVK);
  return mockVK;
}

/**
 * Calculate SHA-256 hash of circuit artifacts
 * Used for integrity verification in circuit-manager
 */
function calculateCircuitHash(compiledCircuit, verifyingKey) {
  const hash = crypto.createHash("sha256");
  hash.update(compiledCircuit);
  hash.update(verifyingKey);
  return hash.digest("hex");
}

/**
 * Generate all artifacts for a specific circuit size
 */
function generateCircuitArtifacts(size) {
  const circuitDir = path.join(STATIC_DIR, `ebsl_${size}`);

  console.log(`\nüì¶ Generating circuit artifacts for size ${size}...`);

  // Ensure directory exists
  if (!fs.existsSync(circuitDir)) {
    fs.mkdirSync(circuitDir, { recursive: true });
  }

  // Generate artifacts
  const compiledCircuit = generateMockCompiledCircuit(size);
  const settings = generateMockSettings(size);
  const verifyingKey = generateMockVerifyingKey(size);

  // Write files
  const compiledPath = path.join(circuitDir, "_compiled.wasm");
  const settingsPath = path.join(circuitDir, "settings.json");
  const vkPath = path.join(circuitDir, "vk.key");

  fs.writeFileSync(compiledPath, compiledCircuit);
  fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));
  fs.writeFileSync(vkPath, verifyingKey);

  // Calculate hash for integrity verification
  const hash = calculateCircuitHash(compiledCircuit, verifyingKey);

  console.log(`  ‚úÖ _compiled.wasm: ${(compiledCircuit.length / 1024).toFixed(2)} KB`);
  console.log(`  ‚úÖ settings.json: ${(JSON.stringify(settings).length / 1024).toFixed(2)} KB`);
  console.log(`  ‚úÖ vk.key: ${(verifyingKey.length / 1024).toFixed(2)} KB`);
  console.log(`  üîê SHA-256: ${hash}`);

  return { size, hash };
}

/**
 * Generate circuit hash manifest
 * This is imported by circuit-manager.ts for integrity verification
 */
function generateHashManifest(circuitHashes) {
  const manifestContent = `/**
 * Circuit Hash Manifest
 * Generated by scripts/generate-mock-circuits.js
 *
 * These SHA-256 hashes are used for integrity verification when downloading circuits.
 * Update this file whenever circuit artifacts are regenerated.
 */

export const CIRCUIT_HASHES: Record<string, string> = {
${circuitHashes.map(({ size, hash }) => `  "${size}": "${hash}",`).join("\n")}
};
`;

  const manifestPath = path.join(__dirname, "..", "src", "lib", "zkml", "circuit-hashes.ts");
  fs.writeFileSync(manifestPath, manifestContent);
  console.log(`\n‚úÖ Generated hash manifest: ${manifestPath}`);
}

/**
 * Main execution
 */
function main() {
  console.log("üîß Mock Circuit Artifact Generator");
  console.log("==================================\n");
  console.log("üìÅ Output directory:", STATIC_DIR);

  // Ensure static circuits directory exists
  if (!fs.existsSync(STATIC_DIR)) {
    fs.mkdirSync(STATIC_DIR, { recursive: true });
  }

  // Generate artifacts for all circuit sizes
  const circuitHashes = CIRCUIT_SIZES.map((size) => generateCircuitArtifacts(size));

  // Generate hash manifest for TypeScript import
  generateHashManifest(circuitHashes);

  console.log("\n‚ú® Circuit generation complete!");
  console.log("\nüìã Summary:");
  console.log(`   - Generated ${CIRCUIT_SIZES.length} circuit sizes: ${CIRCUIT_SIZES.join(", ")}`);
  console.log(`   - Total artifacts: ${CIRCUIT_SIZES.length * 3} files`);
  console.log(`   - Location: static/circuits/ebsl_*`);
  console.log("\n‚ö†Ô∏è  NOTE: These are MOCK circuits for demo purposes.");
  console.log("   For production, generate real circuits using Notebooks/EBSL_EZKL.py\n");
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = { generateCircuitArtifacts, calculateCircuitHash };
